#!/bin/env bash

# FULL DISCLOSURE: MOSTLY GENERATED BY CHATGPT

mkdir -p csvs
ulimit -s unlimited

output/experiment1-baseline | gawk '
BEGIN {
    OFS = ","
    print "kernel","length","avg_time_ns","min_time_ns","max_time_ns","avg_cycles","min_cycles","max_cycles"
}

/^Running:/ {
    line = $0

    # Remove ANSI escape sequences
    gsub(/\033\[[0-9;]*m/, "", line)

    sub(/^Running: /, "", line)
    sub(/ 10 times$/, "", line)

    # kernel = everything before "("
    kernel = line
    sub(/\(.*$/, "", kernel)

    # extract last argument inside parentheses using RSTART/RLENGTH
    if (match(line, /\([^)]*\)/)) {
        argstr = substr(line, RSTART+1, RLENGTH-2)        # remove surrounding parens
        cnt = split(argstr, parts, ",")
        lastarg = parts[cnt]
        gsub(/^[ \t]+|[ \t]+$/, "", lastarg)             # trim whitespace
    } else {
        lastarg = ""
    }
}

/^Test complete/ {
    # match the numeric parts; keep tolerant for scientific notation
    if (match($0, /Average runtime: ([0-9.eE+-]+) ns \| Min runtime: ([0-9.eE+-]+) ns \| Max runtime: ([0-9.eE+-]+) ns \| Average cycles: ([0-9.eE+-]+) \| Min cycles: ([0-9.eE+-]+) \| Max cycles: ([0-9.eE+-]+)/, m)) {
        avg_time = m[1]
        min_time = m[2]
        max_time = m[3]
        avg_cycles = m[4]
        min_cycles = m[5]
        max_cycles = m[6]
        print kernel, lastarg, avg_time, min_time, max_time, avg_cycles, min_cycles, max_cycles
    } else {
        # fallback: try a looser parse (optional)
        # print "PARSE_FAIL",$0 > "/dev/stderr"
    }
}
' > csvs/experiment1-baseline.csv

output/experiment1-vectorized | gawk '
BEGIN {
    OFS = ","
    print "kernel","length","avg_time_ns","min_time_ns","max_time_ns","avg_cycles","min_cycles","max_cycles"
}

/^Running:/ {
    line = $0

    # Remove ANSI escape sequences
    gsub(/\033\[[0-9;]*m/, "", line)

    sub(/^Running: /, "", line)
    sub(/ 10 times$/, "", line)

    # kernel = everything before "("
    kernel = line
    sub(/\(.*$/, "", kernel)

    # extract last argument inside parentheses using RSTART/RLENGTH
    if (match(line, /\([^)]*\)/)) {
        argstr = substr(line, RSTART+1, RLENGTH-2)        # remove surrounding parens
        cnt = split(argstr, parts, ",")
        lastarg = parts[cnt]
        gsub(/^[ \t]+|[ \t]+$/, "", lastarg)             # trim whitespace
    } else {
        lastarg = ""
    }
}

/^Test complete/ {
    # match the numeric parts; keep tolerant for scientific notation
    if (match($0, /Average runtime: ([0-9.eE+-]+) ns \| Min runtime: ([0-9.eE+-]+) ns \| Max runtime: ([0-9.eE+-]+) ns \| Average cycles: ([0-9.eE+-]+) \| Min cycles: ([0-9.eE+-]+) \| Max cycles: ([0-9.eE+-]+)/, m)) {
        avg_time = m[1]
        min_time = m[2]
        max_time = m[3]
        avg_cycles = m[4]
        min_cycles = m[5]
        max_cycles = m[6]
        print kernel, lastarg, avg_time, min_time, max_time, avg_cycles, min_cycles, max_cycles
    } else {
        # fallback: try a looser parse (optional)
        # print "PARSE_FAIL",$0 > "/dev/stderr"
    }
}
' > csvs/experiment1-vectorized.csv

output/experiment2-baseline | gawk '
BEGIN {
    OFS = ","
    print "length,avg_time_ns,min_time_ns,max_time_ns,avg_cycles,min_cycles,max_cycles"
}

/^Creating arrays of length/ {
    arr_length = $5
}

/^Test complete/ {
    # match the numeric parts; keep tolerant for scientific notation
    if (match($0, /Average runtime: ([0-9.eE+-]+) ns \| Min runtime: ([0-9.eE+-]+) ns \| Max runtime: ([0-9.eE+-]+) ns \| Average cycles: ([0-9.eE+-]+) \| Min cycles: ([0-9.eE+-]+) \| Max cycles: ([0-9.eE+-]+)/, m)) {
        avg_time = m[1]
        min_time = m[2]
        max_time = m[3]
        avg_cycles = m[4]
        min_cycles = m[5]
        max_cycles = m[6]
        print arr_length, avg_time, min_time, max_time, avg_cycles, min_cycles, max_cycles
    } else {
        # fallback: try a looser parse (optional)
        # print "PARSE_FAIL",$0 > "/dev/stderr"
    }
}
' > csvs/experiment2-baseline.csv

output/experiment2-vectorized | gawk '
BEGIN {
    OFS = ","
    print "length,avg_time_ns,min_time_ns,max_time_ns,avg_cycles,min_cycles,max_cycles"
}

/^Creating arrays of length/ {
    arr_length = $5
}

/^Test complete/ {
    # match the numeric parts; keep tolerant for scientific notation
    if (match($0, /Average runtime: ([0-9.eE+-]+) ns \| Min runtime: ([0-9.eE+-]+) ns \| Max runtime: ([0-9.eE+-]+) ns \| Average cycles: ([0-9.eE+-]+) \| Min cycles: ([0-9.eE+-]+) \| Max cycles: ([0-9.eE+-]+)/, m)) {
        avg_time = m[1]
        min_time = m[2]
        max_time = m[3]
        avg_cycles = m[4]
        min_cycles = m[5]
        max_cycles = m[6]
        print arr_length, avg_time, min_time, max_time, avg_cycles, min_cycles, max_cycles
    } else {
        # fallback: try a looser parse (optional)
        # print "PARSE_FAIL",$0 > "/dev/stderr"
    }
}
' > csvs/experiment2-vectorized.csv
