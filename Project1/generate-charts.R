#!/bin/env Rscript

# FULL DISCLOSURE: MOSTLY GENERATED BY CHATGPT

library(ggplot2)
library(tidyverse)

# EXPERIMENT 1

exp1base <- read.csv("csvs/experiment1-baseline.csv") %>% mutate(source = "Baseline")
exp1vect <- read.csv("csvs/experiment1-vectorized.csv") %>% mutate(source = "Vectorized")

flop_map <- c("streaming_fma" = 2,
              "reduction" = 2,
              "element_multiply" = 1)

length_map <- c("L1_ARR_LENGTH" = 20000,
                "L2_ARR_LENGTH" = 500000,
                "L3_ARR_LENGTH" = 1000000,
                "DRAM_ARR_LENGTH" = 5000000)

exp1 <- bind_rows(exp1base, exp1vect) %>%
  mutate(arr_len = length_map[length],
         flop_count = flop_map[kernel],
         gflops = flop_count * arr_len / avg_time_ns,
         gflops = round(gflops, 3))   # round nicely

data_long <- exp1 %>%
  pivot_longer(cols = c(avg_time_ns, avg_cycles),
               names_to = "metric",
               values_to = "avg") %>%
  mutate(min = ifelse(metric == "avg_time_ns", min_time_ns, min_cycles),
         max = ifelse(metric == "avg_time_ns", max_time_ns, max_cycles),
         length = recode(length,
                         "L1_ARR_LENGTH" = "L1",
                         "L2_ARR_LENGTH" = "L2",
                         "L3_ARR_LENGTH" = "L3",
                         "DRAM_ARR_LENGTH" = "DRAM"),
        length_source = paste(length, source)
  )

data_long$length_source <- factor(
  data_long$length_source,
  levels = c("L1 Baseline", "L1 Vectorized",
             "L2 Baseline", "L2 Vectorized",
             "L3 Baseline", "L3 Vectorized",
             "DRAM Baseline", "DRAM Vectorized")
)

kernels <- unique(data_long$kernel)

for (k in kernels) {
  plot_data <- filter(data_long, kernel == k)

  ratio_tbl <- exp1 %>%
    filter(kernel == k) %>%
    select(length, source, avg_time_ns) %>%
    pivot_wider(names_from = source, values_from = avg_time_ns) %>%
    mutate(ratio = Baseline / Vectorized)

  cat("\nKernel:", k, "\n")
  print(ratio_tbl %>% select(length, ratio))

  for (len in names(length_map)) {
    base_val <- exp1 %>% filter(kernel == k, length == len, source == "Baseline") %>% pull(gflops)
    vect_val <- exp1 %>% filter(kernel == k, length == len, source == "Vectorized") %>% pull(gflops)
    if (length(base_val) == 0 || length(vect_val) == 0) next
    cat(len,
        sprintf("Baseline: %.3f GFLOP/s | Vectorized: %.3f GFLOP/s\n",
                base_val, vect_val))
  }

  # Compute separate scales for each metric for plotting
  time_max <- max(plot_data$max[plot_data$metric == "avg_time_ns"])
  cycles_max <- max(plot_data$max[plot_data$metric == "avg_cycles"])
  scale_factor <- time_max / cycles_max

  plot_data <- plot_data %>%
    mutate(scaled_avg = ifelse(metric == "avg_cycles", avg * scale_factor, avg),
           scaled_min = ifelse(metric == "avg_cycles", min * scale_factor, min),
           scaled_max = ifelse(metric == "avg_cycles", max * scale_factor, max))

  p <- ggplot(plot_data, aes(x = length_source, y = scaled_avg, fill = metric)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
    geom_errorbar(aes(ymin = scaled_min, ymax = scaled_max), position = position_dodge(width = 0.9), width = 0.25) +
    scale_fill_manual(values = c("avg_time_ns" = "skyblue", "avg_cycles" = "orange"),
                      labels = c("Time (ns)", "Cycles")) +
    scale_y_continuous(
      name = "Time (ns)",
      sec.axis = sec_axis(~. / scale_factor, name = "Cycles")
    ) +
    labs(title = paste("Experiment 1 Performance (Kernel ", k, ")", sep = ""), x = "Length", fill = "Metric") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  print(p)
}

# EXPERIMENT 2

# Load CSV
exp2base <- read.csv("csvs/experiment2-baseline.csv") %>% mutate(source = "Baseline")
exp2vect <- read.csv("csvs/experiment2-vectorized.csv") %>% mutate(source = "Vectorized")

# Define X positions for vertical lines
vlines <- c(30038, 567979, 1048577)

# Combine into one dataframe
exp2 <- bind_rows(exp2base, exp2vect)

exp2 <- exp2 %>%
  mutate(section = cut(length, breaks = c(-Inf, vlines, Inf), labels = paste0("S", 1:(length(vlines) + 1))))

section_colors <- c("S1" = "#999999", "S2" = "#666666", "S3" = "#333333", "S4" = "#000000")

ggplot(exp2, aes(x = length, y = avg_time_ns, color = source, fill = source)) +
  geom_line(linewidth = 1) +
  geom_ribbon(aes(ymin = min_time_ns, ymax = max_time_ns), alpha = 0.2, color = NA) +
  geom_vline(xintercept = vlines, linetype = "dashed", color = "darkgrey") +
  geom_smooth(data = filter(exp2, source == "Baseline"), aes(group = interaction(source, section)), method = "lm", se = FALSE, linetype = "dotdash", color = "cyan") +
  geom_smooth(data = filter(exp2, source == "Vectorized"), aes(group = interaction(source, section)), method = "lm", se = FALSE, linetype = "dotdash", color = "red4") +
  labs(title = "Experiment 2 Performance (time)",
       x = "Array Length",
       y = "Time (ns)") +
  scale_color_manual(values = c("blue", "red")) +
  scale_fill_manual(values = c("blue", "red")) +
  theme_classic()

ggplot(exp2, aes(x = length, y = avg_cycles / length, color = source, fill = source)) +
  geom_line(linewidth = 1) +
  geom_ribbon(aes(ymin = min_cycles / length, ymax = max_cycles / length), alpha = 0.2, color = NA) +
  geom_vline(xintercept = vlines, linetype = "dashed", color = "darkgrey") +
  geom_smooth(data = filter(exp2, source == "Baseline"), aes(group = interaction(source, section)), method = "lm", se = FALSE, linetype = "dotdash", color = "cyan") +
  geom_smooth(data = filter(exp2, source == "Vectorized"), aes(group = interaction(source, section)), method = "lm", se = FALSE, linetype = "dotdash", color = "red4") +
  labs(title = "Experiment 2 Performance (CPE)",
       x = "Array Length",
       y = "Cycles") +
  scale_color_manual(values = c("blue", "red")) +
  scale_fill_manual(values = c("blue", "red")) +
  theme_classic()

# Experiment 3

# Load both files
exp3base <- read.csv("csvs/experiment3-baseline.csv") %>% mutate(source = "Baseline")
exp3vect <- read.csv("csvs/experiment3-vectorized.csv") %>% mutate(source = "Vectorized")

# Combine
exp3 <- bind_rows(exp3base, exp3vect)

# Pivot long so that time and cycles are both in one column
data_long <- exp3 %>%
  pivot_longer(cols = c(avg_time_ns, avg_cycles),
               names_to = "metric",
               values_to = "avg") %>%
  mutate(min = ifelse(metric == "avg_time_ns", min_time_ns, min_cycles),
         max = ifelse(metric == "avg_time_ns", max_time_ns, max_cycles),
         combo = paste(
           ifelse(alignment == "aligned", "Aligned", "Misaligned"),
           ifelse(tail == "tail", "Tail", "No-Tail"),
           source
         ))

# Define explicit order of bars
data_long$combo <- factor(
  data_long$combo,
  levels = c("Aligned No-Tail Baseline", "Aligned No-Tail Vectorized",
             "Aligned Tail Baseline",    "Aligned Tail Vectorized",
             "Misaligned No-Tail Baseline", "Misaligned No-Tail Vectorized",
             "Misaligned Tail Baseline",    "Misaligned Tail Vectorized")
)

# Compute scale factor for dual axis
time_max   <- max(data_long$max[data_long$metric == "avg_time_ns"])
cycles_max <- max(data_long$max[data_long$metric == "avg_cycles"])
scale_factor <- time_max / cycles_max

plot_data <- data_long %>%
  mutate(scaled_avg = ifelse(metric == "avg_cycles", avg * scale_factor, avg),
         scaled_min = ifelse(metric == "avg_cycles", min * scale_factor, min),
         scaled_max = ifelse(metric == "avg_cycles", max * scale_factor, max))

# Plot
p <- ggplot(plot_data, aes(x = combo, y = scaled_avg, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = scaled_min, ymax = scaled_max),
                position = position_dodge(width = 0.9), width = 0.25) +
  scale_fill_manual(values = c("avg_time_ns" = "skyblue", "avg_cycles" = "orange"),
                    labels = c("Time (ns)", "Cycles")) +
  scale_y_continuous(
    name = "Time (ns)",
    sec.axis = sec_axis(~. / scale_factor, name = "Cycles")
  ) +
  labs(title = "Experiment 3 Performance", x = "", fill = "Metric") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))  # tilt labels

print(p)

# Experiment 4

# Load both CSVs
exp4base <- read.csv("csvs/experiment4-baseline.csv") %>% mutate(source = "Baseline")
exp4vect <- read.csv("csvs/experiment4-vectorized.csv") %>% mutate(source = "Vectorized")

# Combine
exp4 <- bind_rows(exp4base, exp4vect)

# Pivot long: put time/cycles into one column
data_long <- exp4 %>%
  pivot_longer(cols = c(avg_time_ns, avg_cycles),
               names_to = "metric",
               values_to = "avg") %>%
  mutate(min = ifelse(metric == "avg_time_ns", min_time_ns, min_cycles),
         max = ifelse(metric == "avg_time_ns", max_time_ns, max_cycles),
         # Combine stride + source into one x-axis label
         stride_label = ifelse(stride == "gen", "Random", stride),
         combo = paste("Stride", stride_label, source))

# Factor for consistent ordering
data_long$combo <- factor(
  data_long$combo,
  levels = c("Stride 1 Baseline",  "Stride 1 Vectorized",
             "Stride 2 Baseline",  "Stride 2 Vectorized",
             "Stride 5 Baseline",  "Stride 5 Vectorized",
             "Stride 16 Baseline", "Stride 16 Vectorized",
             "Stride 50 Baseline", "Stride 50 Vectorized",
             "Stride Random Baseline", "Stride Random Vectorized")
)

# Compute scaling factor for dual axis
time_max   <- max(data_long$max[data_long$metric == "avg_time_ns"])
cycles_max <- max(data_long$max[data_long$metric == "avg_cycles"])
scale_factor <- time_max / cycles_max

plot_data <- data_long %>%
  mutate(scaled_avg = ifelse(metric == "avg_cycles", avg * scale_factor, avg),
         scaled_min = ifelse(metric == "avg_cycles", min * scale_factor, min),
         scaled_max = ifelse(metric == "avg_cycles", max * scale_factor, max))

# Plot
p <- ggplot(plot_data, aes(x = combo, y = scaled_avg, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = scaled_min, ymax = scaled_max),
                position = position_dodge(width = 0.9), width = 0.25) +
  scale_fill_manual(values = c("avg_time_ns" = "skyblue", "avg_cycles" = "orange"),
                    labels = c("Time (ns)", "Cycles")) +
  scale_y_continuous(
    name = "Time (ns)",
    sec.axis = sec_axis(~. / scale_factor, name = "Cycles")
  ) +
  labs(title = "Experiment 4 Performance", x = "", fill = "Metric") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # tilt labels

print(p)

# Experiment 5

# Load both CSVs
exp5base <- read.csv("csvs/experiment5-baseline.csv") %>% mutate(source = "Baseline")
exp5vect <- read.csv("csvs/experiment5-vectorized.csv") %>% mutate(source = "Vectorized")

# Combine
exp5 <- bind_rows(exp5base, exp5vect)

# Pivot long so both metrics are in one column
data_long <- exp5 %>%
  pivot_longer(cols = c(avg_time_ns, avg_cycles),
               names_to = "metric",
               values_to = "avg") %>%
  mutate(min = ifelse(metric == "avg_time_ns", min_time_ns, min_cycles),
         max = ifelse(metric == "avg_time_ns", max_time_ns, max_cycles),
         combo = paste("Float", bits, " ", source, sep = ""))

# Order the axis
data_long$combo <- factor(
  data_long$combo,
  levels = c("Float32 Baseline", "Float32 Vectorized",
             "Float64 Baseline", "Float64 Vectorized")
)

# Compute scaling for dual axis
time_max   <- max(data_long$max[data_long$metric == "avg_time_ns"])
cycles_max <- max(data_long$max[data_long$metric == "avg_cycles"])
scale_factor <- time_max / cycles_max

plot_data <- data_long %>%
  mutate(scaled_avg = ifelse(metric == "avg_cycles", avg * scale_factor, avg),
         scaled_min = ifelse(metric == "avg_cycles", min * scale_factor, min),
         scaled_max = ifelse(metric == "avg_cycles", max * scale_factor, max))

# Plot
p <- ggplot(plot_data, aes(x = combo, y = scaled_avg, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = scaled_min, ymax = scaled_max),
                position = position_dodge(width = 0.9), width = 0.25) +
  scale_fill_manual(values = c("avg_time_ns" = "skyblue", "avg_cycles" = "orange"),
                    labels = c("Time (ns)", "Cycles")) +
  scale_y_continuous(
    name = "Time (ns)",
    sec.axis = sec_axis(~. / scale_factor, name = "Cycles")
  ) +
  labs(title = "Experiment 5 Performance", x = "", fill = "Metric") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p)
